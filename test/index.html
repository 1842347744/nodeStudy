<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
    <div>
        是的
        <p>
            阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化阿尔法时的法国和时的法国和aSFDGHJASDGFH这东西法规及阿斯蒂芬和国际化
        </p>
    </div>
</body>
<script>
    // function Person() {
    //     Person.prototype.a = 123;
    //     Person.prototype.sayHello = function () {
    //     alert("hello");
    //     }
    // };
    // var person1 = new Person();
    // console.log(person1.a);
    // console.log(person1.__proto__);
    // // console.log(person1.sayHello());\
    // console.log(Person.prototype);
    // console.log(Person.prototype.constructor);
    // console.log(Person.prototype.__proto__);
    // console.log(Object.prototype);
    
// 没有参数的情况
// var s1 = Symbol();
// var s2 = Symbol();
// s1 === s2 // false
// 有参数的情况
// var s1 = Symbol("foo");
// var s2 = Symbol("foo");
// s1 === s2 // false
// console.log(s1 === s2);
// var a = [1, 2];
// var b = [1, 2];
// console.log(a === b);

// var neg1 = /^[1-9][0-9]b*$/;
// console.log(neg1.test('1'));
// console.log(neg1.test('19b'));
// var neg2 = /<.*?>/;
// console.log(neg2.test('<h1>xzxzx</h1>'));
// var neg = /^[-]?[0-9]+(\.[0-9]+)?$ /;
// var neg = /^[-]?[0-9]+\.[0-9]+$/;
// // console.log(neg.test('11'));
// var neg2 = /^-?[1-9]\d*|0$/
// console.log(neg2.test('-11'));

// var neg4 = /^-?(\d|([1-9]\d*))\.\d+$/; //匹配浮点数

// var neg5 = /^\D$/;
// console.log(neg5.test('1'));


// 手写深拷贝 区分数组和对象

// let obj = [1, 2, 3]; 
// // let obj = {
// //     name: 'ywc',
// //     age: '24'
// // };
// let arr2 = []; 
// let obj2 = {};
// if (obj.length > 0) {
//     for (let i = 0 ; i < obj.length; i++) {
//         arr2[i] = obj[i];
//     }
// } else  {
//     for (let item in obj) {
//         obj2[item] = obj[item]
//     }
// }
// arr2.push('13');
// console.log(arr2);
// console.log(obj);


// var arr=[2,3,4,"haa"];
// var object={"name":"maomao","age":20};
// console.log(Array.prototype.isPrototypeOf(arr));    //true
// console.log(Array.prototype.isPrototypeOf(object)); //false
// console.log(Object.prototype.isPrototypeOf(arr));   //true 
// console.log(arr.constructor); //function Array() { [native code] }
// console.log(obj.constructor); //function Object() { [native code] }
// console.log(arr.constructor==Array); //true
// console.log(arr.constructor==Object); //false
// console.log(obj.constructor==Array); //false
// console.log(obj.constructor==Object); //true

// 方法一 防抖
// 所谓防抖，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。
// var timer = null;
// var dayin = function dayin() {
//     alert('你滚动了滑动条！');
// }
// window.onscroll = () => {
//     if (timer) {
//         clearTimeout(timer); // 当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时
//         timer = setTimeout(dayin, 2000) 
//     } else {
//         timer = setTimeout(dayin, 2000)  // 当前并没有在计时，那么就开始一个计时
//     }
// }
// 方法二 防抖 
// var timer = null;
// var dayin = function dayin() {
//     alert('你滚动了滑动条！');
// }
// window.onscroll = () => {
//     debounce(dayin, 2000)
// } 
// function debounce (fn, delay) {
//     function xx(fn, delay) {
//         if (timer) {
//             clearTimeout(timer) // 当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时
//             return timer = setTimeout(fn, delay) 
//         } else {
//             return timer = setTimeout(fn, delay) // 当前并没有在计时，那么就开始一个计时
//         }
//     }
//     return xx(dayin, 2000)
// }

// 节流
// 所谓节流，是指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。
// var timer = null; 
// var dayin = function dayin() {
//     alert('你滚动了滑动条！');
// }
// window.onscroll = () => {
//     if (timer) {
//         timer = setTimeout(dayin, 2000) 
//     } else {
//         timer = setTimeout(dayin, 2000)
//     }
// }
function throttle(fn,delay){
    // console.log('1212');
    // console.log(fn);
    let valid = true;
    return function() {
        if(!valid){
           //休息时间 暂不接客
           console.log('在间隔时间内');
           return false;
        }
        console.log(1);
        // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false;
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */

// 以下照旧
function showTop () {
//     var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
//     var date = new Date();
// 　　console.log('滚动条位置：' + scrollTop);
//     console.log(date);
    alert('提示')
}
window.onscroll = throttle(showTop,2000) 
// window.onscroll = () => {
//     console.log('滚动了一下');
// }
</script>
</html>